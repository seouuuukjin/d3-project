<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js" integrity="sha512-5mCB0Kvv97yTzqo0174qxPjMisck/WlK51+mw/RV7UfYbtHI8LuLR82BzZuxHUKSfbh75u9cZHgUcqrZDaBJuA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <title>Intel Xeon Interconnect Traffic Visualization</title>
    <style>
        body {
            background: #eee;
            overflow-y: scroll;
        }
        /* ////////////////////////////////////////////////////////////// */
        
        #svg-container {
            border: 2px solid black;
            padding: 3px;
        }
        
        #svg-container h2,
        #svg-container p {
            text-align: center;
        }
        
        .axis {
            opacity: 0.4;
        }
        
        .axis:hover {
            opacity: 1;
        }
        
        #my_dataviz {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #my_stacked_bar_chart_scrollbar {
            width: 70%;
            /* Space between SVG and my_stacked_bar_chart_scrollbar */
            margin-top: 10px;
            margin-left: 50px;
        }
        /* ////////////////////////////////////////////////////////////// */
        
        #parallel-path {
            stroke: #000;
            stroke-opacity: .4;
            fill: none;
        }
        
        .parallel_axis text {
            font: 10px sans-serif;
        }
        
        .parallel_legend rect {
            fill: white;
            stroke: black;
        }
        
        .parallel_legend text {
            font-size: 14px;
        }
        
        #my_parallel_coordinates_scrollbar {
            width: 85%;
            /* Space between SVG and my_parallel_coordinates_scrollbar */
            margin-top: 0.5px;
            margin-left: 50px;
        }
        /* ////////////////////////////////////////////////////////////// */
        
        #my_heatmap_scrollbar {
            width: 85%;
            margin-top: 0.5px;
            margin-left: 50px;
        }
        
        #svg-heatmap-container {
            background: #e5e5e5;
            border: 2px solid black;
            padding: 3px;
            /* Adds some padding to the content inside the div (optional) */
        }
        
        #svg-heatmap-container h2,
        #svg-heatmap-container p {
            text-align: center;
        }
        
        #svg-heatmap-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            /* or set to the height you want */
        }
        
        #title {
            margin-bottom: 10px;
            /* Adjust as needed */
        }
        /* ////////////////////////////////////////////////////////////// */
    </style>
</head>

<body>



    <div id="my_dataviz">
        <div id="svg-container" style="position: relative;">
            <h2>Stacked Bar Chart</h2>
            <svg id="my_stacked_bar_chart_svg"></svg>
            <!-- Include the my_stacked_bar_chart_scrollbar -->
            <input type="range" id="my_stacked_bar_chart_scrollbar" min="0" max="300" step="10" value="0" class="my_stacked_bar_chart_scrollbar">
            <p>Timeline Cursor <span id="my_stacked_bar_char_sliderValue"></span></p>
            <div id="my_tooltip">
                <div class="content"></div>
            </div>
        </div>
        <br>
        <div id="svg-container" style="position: relative;">
            <h2>Parallel Coordinates</h2>
            <svg id="my_parallel_coordinates_svg"></svg>
            <!-- Include the my_stacked_bar_chart_scrollbar -->
            <input type="range" id="my_parallel_coordinates_scrollbar" min="0" max="300" step="10" value="0" class="my_parallel_coordinates_scrollbar">
            <p>Timeline Cursor <span id="my_parallel_coordinates_sliderValue"></span></p>
        </div>
        <br>
        <div id="svg-heatmap-container" style="position: relative;">
            <h2 id="title">Core Map</h2>
            <svg id="my_heatmap_svg"></svg>
            <input type="range" id="my_heatmap_scrollbar" min="0" max="300" step="10" value="0" class="my_heatmap_scrollbar">
            <p>Timeline Cursor <span id="my_heatmap_sliderValue"></span></p>
        </div>

    </div>



    <script>
        // set the dimensions and margins of the graph
        var margin = {
            top: 20,
            right: 30,
            bottom: 20,
            left: 70
        };

        width_stacked_bar_chart = 660 - margin.left - margin.right;
        height_stacked_bar_chart = 400 - margin.top - margin.bottom;

        // svg 선택해서 사이즈 조절
        const svg_stacked_bar_chart = d3.select("#my_stacked_bar_chart_svg")
            .attr("width", width_stacked_bar_chart + margin.left + margin.right)
            .attr("height", height_stacked_bar_chart + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        margin = {
            top: 40,
            right: 30,
            bottom: 2,
            left: 70
        };

        width_parallel_coordinates = 960 - margin.left - margin.right;
        height_parallel_coordinates = 500 - margin.top - margin.bottom;

        const svg_parallel_coordinates = d3.select("#my_parallel_coordinates_svg")
            .attr("width", width_parallel_coordinates + margin.left + margin.right)
            .attr("height", height_parallel_coordinates + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        margin = {
            top: 40,
            right: 30,
            bottom: 2,
            left: 70
        };

        width_heatmap = 1160 - margin.left - margin.right;
        height_heatmap = 1000 - margin.top - margin.bottom;

        const svg_heatmap = d3.select("#my_heatmap_svg")
            .attr("width", width_heatmap)
            .attr("height", height_heatmap);

        // data 불러와서 조절하기
        // stacked bar chart 만들기
        d3.csv("https://raw.githubusercontent.com/seouuuukjin/d3-project/main/mesh_interconnect_traffic_data.csv").then(function(data) {

            // 각 데이터를 숫자로 mapping
            data.forEach(function(d) {
                d.core_num = +d.core_num;
                d.down = +d.down;
                d.top = +d.top;
                d.left = +d.left;
                d.right = +d.right;
                d.time = +d.time;
                d.attack = +d.attack;
            });

            var start_row = 0;
            var end_row = 100;
            var subset_data = data.slice(start_row, end_row);
            // console.log(subset_data);

            parsed_data = []
            for (let core_number = 0; core_number < 10; core_number++) {
                var core_traffic_sum = new Object();
                core_traffic_sum.core_num = core_number;
                core_traffic_sum.top = 0;
                core_traffic_sum.down = 0;
                core_traffic_sum.left = 0;
                core_traffic_sum.right = 0;

                for (const row of subset_data) {
                    if (row.core_num == core_number) {
                        core_traffic_sum.top = core_traffic_sum.top + row.top;
                        core_traffic_sum.down = core_traffic_sum.down + row.down;
                        core_traffic_sum.left = core_traffic_sum.left + row.left
                        core_traffic_sum.right = core_traffic_sum.right + row.right;
                    }
                }
                parsed_data.push(core_traffic_sum);
            }
            // console.log(parsed_data);

            // 트래픽 4가지 방향을 header에서 뽑는다.
            const traffic_from_4_directions = data.columns.slice(1, 5)
                // console.log(traffic_from_4_directions);

            groups = ['Core #0', 'Core #1', 'Core #2', 'Core #3', 'Core #4', 'Core #5', 'Core #6', 'Core #7', 'Core #8', 'Core #9'];
            core_num = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
            // X축
            var x = d3.scaleBand()
                .domain(data.map(function(d) {
                    // console.log(d.core_num);
                    return groups[d.core_num];
                }))
                .range([0, width_stacked_bar_chart])
                .padding([0.2]);

            svg_stacked_bar_chart.append("g")
                .attr("transform", `translate(0, ${height_stacked_bar_chart})`)
                .call(d3.axisBottom(x).tickSizeOuter(0));

            // Y축
            var y = d3.scaleLinear()
                .domain([0, 500000])
                .range([height_stacked_bar_chart, 0]);
            svg_stacked_bar_chart.append("g")
                .attr("class", ".y.axis")
                .call(d3.axisLeft(y));

            // Y축 label 지정해주기
            svg_stacked_bar_chart.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height_stacked_bar_chart / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Traffic Count");

            var xAxis = d3.axisBottom(x);
            var yAxis = d3.axisLeft(y);

            let zScale = d3.scaleOrdinal()
                .domain(traffic_from_4_directions).range(d3.schemeCategory10);


            // 사용할 색깔 지정
            const color = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(traffic_from_4_directions);
            // console.log("color: ", color);

            // 범례 추가하기
            let legend = svg_stacked_bar_chart.append("g");
            legend
                .attr("transform", "translate(510, 30)")
                .call(d3.legendColor().scale(zScale));

            var stack = d3.stack()
                .keys(traffic_from_4_directions)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            var stacked_array = stack(parsed_data);
            //console.log(stacked_array);

            ////////////////////////////////////////////////////////////////                            
            // 스크롤바 추가해서 이벤트마다 업데이트 하도록 설정
            var my_stacked_bar_chart_scrollbar = d3.select("#my_stacked_bar_chart_scrollbar");

            // Update function 정의
            function updateChart(value) {

                // 현재 스크롤바가 지정된 값에서 시작해서 10 time unit만큼 자른다. -> core 10개니까 트래픽 데이터 총 100개씩 해당 됨.
                start_row = value * 10;
                end_row = ((value + 10) * 10) - 1;
                subset_data = data.slice(start_row, end_row);
                // console.log(subset_data, typeof(subset_data));

                // csv에서 불러온 데이터에서 지정된 범위만큼 데이터 더해서 core #가 같은 row끼리 더해서 새로운 dataset을 만든다.
                parsed_data = []
                for (let core_number = 0; core_number < 10; core_number++) {
                    var core_traffic_sum = new Object();
                    core_traffic_sum.core_num = core_number;
                    core_traffic_sum.top = 0;
                    core_traffic_sum.down = 0;
                    core_traffic_sum.left = 0;
                    core_traffic_sum.right = 0;

                    for (const row of subset_data) {
                        if (row.core_num == core_number) {
                            core_traffic_sum.top = core_traffic_sum.top + row.top;
                            core_traffic_sum.down = core_traffic_sum.down + row.down;
                            core_traffic_sum.left = core_traffic_sum.left + row.left
                            core_traffic_sum.right = core_traffic_sum.right + row.right;
                        }
                    }
                    parsed_data.push(core_traffic_sum);
                }

                stacked_array = d3.stack()
                    .keys(traffic_from_4_directions)
                    .order(d3.stackOrderNone)
                    .offset(d3.stackOffsetNone)(parsed_data);

                new_bars = svg_stacked_bar_chart.selectAll(".class_bars")
                    .data(stacked_array);

                // 업데이트를 해도 이전과 같은 색깔을 가지도록 같은 key로 색깔을 mapping 해준다.
                new_bars.attr("fill", function(d) {
                    // console.log("update_d.key: ", d.key);
                    return color(d.key);
                });

                new_bars.selectAll("rect")
                    .data(d => d)
                    //.enter().append("rect")
                    .transition()
                    .duration(1000)
                    .attr("height", d => y(d[0]) - y(d[1]))
                    .attr("width", x.bandwidth())
                    .attr("x", function(d, i) {
                        return x(groups[i]);
                    })
                    .attr("y", d => y(d[1]));


            }

            // Event listener 지정
            my_stacked_bar_chart_scrollbar.on("input", function() {
                updateChart(+this.value);
            });

            ////////////////////////////////////////////////////////////////        
            // Tooltip
            const tooltip = d3.select("#my_tooltip")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "lightgray")
                .style("border", "solid")
                .style("border-color", "blue")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px");

            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function(event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("Traffic From  " + subgroupName + "<br>" + ": " + subgroupValue)
                    .style("opacity", 1)
                    .style('display', 'flex')
            };
            const mousemove = function(event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", `${event.layerX + 10}px`)
                    .style("top", `${event.layerY + 10}px`)
            };
            const mouseleave = function(event, d) {
                tooltip
                    .style('display', 'none')
                    .style("opacity", 0)
            };
            ////////////////////////////////////////////////////////////////

            let bars = svg_stacked_bar_chart.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stacked_array);

            bars.join(
                (enter) => {
                    return enter
                        .append("g")
                        .attr("class", "class_bars")
                        .attr("fill", function(d) {
                            // console.log("d.key: ", d.key);
                            return color(d.key);
                        })
                        .selectAll("rect")
                        // enter a second time = loop subgroup per subgroup to add all rectangles
                        .data(d => d)
                        .join("rect")
                        .attr("x", function(d, i) {
                            return x(groups[i]);
                        })
                        .attr("y", d => y(d[1]))
                        .attr("height", d => y(d[0]) - y(d[1]))
                        .attr("width", x.bandwidth())
                        .attr("stroke", "blue")
                        .on("mouseover", mouseover)
                        .on("mousemove", mousemove)
                        .on("mouseleave", mouseleave);
                },
                (update) => update,
                (exit) => exit.remove()
            );
        })

        // parallel coordinates 만들기
        d3.csv("https://raw.githubusercontent.com/seouuuukjin/d3-project/main/mesh_interconnect_traffic_data.csv").then(function(data) {

            // 각 데이터를 숫자로 mapping
            data.forEach(function(d) {
                d.core_num = +d.core_num;
                d.down = +d.down;
                d.top = +d.top;
                d.left = +d.left;
                d.right = +d.right;
                d.time = +d.time;
                d.attack = +d.attack;
            });

            var start_row = 0;
            var end_row = 100;
            var subset_data = data.slice(start_row, end_row);
            // console.log("subset_data", subset_data);

            parsed_data = []
            for (let core_number = 0; core_number < 10; core_number++) {
                var core_traffic_sum = new Object();
                core_traffic_sum.core_num = core_number;
                core_traffic_sum.top = 0;
                core_traffic_sum.down = 0;
                core_traffic_sum.left = 0;
                core_traffic_sum.right = 0;

                for (const row of subset_data) {
                    if (row.core_num == core_number) {
                        core_traffic_sum.top = core_traffic_sum.top + row.top;
                        core_traffic_sum.down = core_traffic_sum.down + row.down;
                        core_traffic_sum.left = core_traffic_sum.left + row.left
                        core_traffic_sum.right = core_traffic_sum.right + row.right;
                    }
                }
                parsed_data.push(core_traffic_sum);
            }
            // console.log("parsed_data", parsed_data);

            // 4개 축 이름 설정
            var dimensions = ["top", "down", "left", "right"];
            const core_number_list = ['Core 0', 'Core 1', 'Core 2', 'Core 3', 'Core 4', 'Core 5', 'Core 6', 'Core 7', 'Core 8', 'Core 9'];
            // 4개의 y축 범위 정하고 표시할 간격 지정하기
            var y = {};
            for (var i in dimensions) {
                var name = dimensions[i];
                y[name] = d3.scaleLinear().domain([0, 100000]).range([height_parallel_coordinates - 30, 0]);
            }

            // Define the line
            var line = d3.line().defined(function(d) {
                return !isNaN(d[1]);
            });

            var axis = d3.axisLeft();

            var x = d3.scalePoint().range([0, width_parallel_coordinates]).padding(0.3).domain(dimensions);

            var color_parallel_coordinate = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(core_number_list);

            // 선 두번 칠할껀데 뒷배경에 연하게 한번 그리기
            var background = svg_parallel_coordinates.append("g")
                .attr("class", "background")
                .attr("id", "parallel-path")
                .selectAll("path")
                .data(parsed_data)
                .enter().append("path")
                .attr("d", path);


            // 선 두번 칠할껀데 진짜 선 진하게 칠하기
            var foreground = svg_parallel_coordinates.append("g")
                .attr("class", "foreground")
                .attr("id", "parallel-path")
                .selectAll("path")
                .data(parsed_data)
                .enter().append("path")
                .attr("d", path)
                .style("stroke-width", "4px")
                .style("stroke", function(d) {
                    return color_parallel_coordinate(core_number_list[d.core_num]);
                });

            var g = svg_parallel_coordinates.selectAll(".dimension")
                .data(dimensions)
                .enter().append("g")
                .attr("class", "dimension")
                .attr("transform", function(d) {
                    return "translate(" + x(d) + ")";
                });

            g.append("g")
                .attr("class", "axis_label")
                .each(function(d) {
                    d3.select(this).call(axis.scale(y[d]));
                })
                .append("text")
                .style("text-anchor", "middle")
                .style("font-size", "24px") // Adjust the font size
                .style("fill", "black")
                .attr("y", -9)
                .text(function(d) {
                    // console.log(d);
                    return d;
                });

            function path(d) {
                return line(dimensions.map(function(p) {
                    return [x(p), y[p](d[p])];
                }));
            }

            // 위에서 지정한 y축 범위와 간격을 화면에 표시
            var axis = svg_parallel_coordinates.selectAll(".parallel_axis")
                .data(dimensions)
                .enter().append("g")
                .attr("class", "parallel_axis")
                .attr("transform", function(d) {
                    return "translate(" + x(d) + ")";
                })
                .each(function(d) {
                    d3.select(this).call(d3.axisLeft(y[d]));
                });

            // 범례 추가하기    
            var legend_parallel_coordinates = svg_parallel_coordinates.selectAll(".parallel_coordinate_legend")
                .data(color_parallel_coordinate.domain())
                .enter().append("g")
                .attr("class", "parallel_coordinate_legend")
                .attr("transform", function(d, i) {
                    return "translate(0," + i * 20 + ")";
                });

            // 범례에 쓸 색깔 칠해진 직사각형 그리기
            legend_parallel_coordinates.append("rect")
                .attr("x", width_parallel_coordinates)
                .attr("width", 15)
                .attr("height", 15)
                .style("fill", color_parallel_coordinate);

            // 범례에 작성할 설명 표시하기
            legend_parallel_coordinates.append("text")
                .attr("x", width_parallel_coordinates - 4)
                .attr("y", 7)
                .attr("dy", ".35em")
                .style("text-anchor", "end")
                .text(function(d) {
                    return d;
                });


            // 스크롤바 움직였을때 이벤트 핸들링 하기
            d3.select("#my_parallel_coordinates_scrollbar").on("input", function() {
                var newValue = +this.value;

                // Update your data
                // TODO:                
                // 현재 스크롤바가 지정된 값에서 시작해서 10 time unit만큼 자른다. -> core 10개니까 트래픽 데이터 총 100개씩 해당 됨.
                start_row = newValue * 10;
                end_row = ((newValue + 10) * 10) - 1;
                subset_data = data.slice(start_row, end_row);
                // console.log(subset_data, typeof(subset_data));

                // csv에서 불러온 데이터에서 지정된 범위만큼 데이터 더해서 core #가 같은 row끼리 더해서 새로운 dataset을 만든다.
                parsed_data = []
                for (let core_number = 0; core_number < 10; core_number++) {
                    var core_traffic_sum = new Object();
                    core_traffic_sum.core_num = core_number;
                    core_traffic_sum.top = 0;
                    core_traffic_sum.down = 0;
                    core_traffic_sum.left = 0;
                    core_traffic_sum.right = 0;

                    for (const row of subset_data) {
                        if (row.core_num == core_number) {
                            core_traffic_sum.top = core_traffic_sum.top + row.top;
                            core_traffic_sum.down = core_traffic_sum.down + row.down;
                            core_traffic_sum.left = core_traffic_sum.left + row.left
                            core_traffic_sum.right = core_traffic_sum.right + row.right;
                        }
                    }
                    parsed_data.push(core_traffic_sum);
                }

                // Redraw the chart
                redraw(parsed_data);
            });

            function redraw(parsed_data) {

                // 이전 차트 지우기
                d3.select(".parallel-path").remove();
                d3.select(".foreground").remove();
                d3.select(".background").remove();

                // 새로운 업데이트 된 값들로 다시 똑같이 새로 그리기(처음 그릴때와 똑같이 반복하면 된다.)
                // 선 두번 칠할껀데 뒷배경에 연하게 한번 그리기
                var background = svg_parallel_coordinates.append("g")
                    .attr("class", "background")
                    .attr("id", "parallel-path")
                    .selectAll("path")
                    .data(parsed_data)
                    .enter().append("path")
                    .attr("d", path);

                // 선 두번 칠할껀데 진짜 선 진하게 칠하기
                var foreground = svg_parallel_coordinates.append("g")
                    .attr("class", "foreground")
                    .attr("id", "parallel-path")
                    .selectAll("path")
                    .data(parsed_data)
                    .enter().append("path")
                    .attr("d", path)
                    .style("stroke-width", "4px")
                    .style("stroke", function(d) {
                        return color_parallel_coordinate(core_number_list[d.core_num]);
                    });

                var g = svg_parallel_coordinates.selectAll(".dimension")
                    .data(dimensions)
                    .enter().append("g")
                    .attr("class", "dimension")
                    .attr("transform", function(d) {
                        return "translate(" + x(d) + ")";
                    });

                g.append("g")
                    .attr("class", "axis_label")
                    .each(function(d) {
                        d3.select(this).call(axis.scale(y[d]));
                    })
                    .append("text")
                    .style("text-anchor", "middle")
                    .style("font-size", "24px") // Adjust the font size
                    .style("fill", "black")
                    .attr("y", -9)
                    .text(function(d) {
                        // console.log(d);
                        return d;
                    });

                function path(d) {
                    return line(dimensions.map(function(p) {
                        return [x(p), y[p](d[p])];
                    }));
                }

                // 위에서 지정한 y축 범위와 간격을 화면에 표시
                var axis = svg_parallel_coordinates.selectAll(".parallel_axis")
                    .data(dimensions)
                    .enter().append("g")
                    .attr("class", "parallel_axis")
                    .attr("transform", function(d) {
                        return "translate(" + x(d) + ")";
                    })
                    .each(function(d) {
                        d3.select(this).call(d3.axisLeft(y[d]));
                    });
            }
        });


        // heatmap 만들기
        d3.csv("https://raw.githubusercontent.com/seouuuukjin/d3-project/main/mesh_interconnect_traffic_data.csv").then(function(data) {

            var xScale = d3.scaleLinear()
                .domain([0, 10]) // Your data range
                .range([0, width_heatmap]); // Your visual range

            var yScale = d3.scaleLinear()
                .domain([0, 10]) // Your data range
                .range([0, height_heatmap]); // Your visual range

            // core로 사용할 정사각형 박스의 사이즈 정하기
            var squareSize = 55;

            // core의 트래픽의 크기를 나타낼 arrow size
            var arrowLength = 30;

            // 화살표 사이즈를 데이터에 맞게 조절하기 위한 scale 설정
            var sizeScale = d3.scaleLinear()
                .domain([0, 40]) // input domain: 0 to max traffic
                .range([10, 50]); // output range: sizes you want

            var widthScale = d3.scaleLinear()
                .domain([0, 200]) // input domain: 0 to max traffic
                .range([1, 100]); // output range: widths you want

            // core로 사용할 정사각형 박스 10개의 X와 Y좌표를 비율에 맞게 계산해놓기
            var xPos = [width_heatmap / 7, 3 * width_heatmap / 8, 5 * width_heatmap / 8, 6 * width_heatmap / 7];
            var yPos = [height_heatmap / 6, 2 * height_heatmap / 4, 5 * height_heatmap / 6];

            // Define your labels
            var labels = ["Core 0", "Core 1", "Core 2", "Core 3", "Core 4", "Core 5", "Core 6", "Core 7", "Core 8", "Core 9"];
            var labelIndex = 0;

            // core로 사용할 정사각형 박스 10개 생성하기
            // First row
            for (let i = 0; i < 4; i++) {
                var x = xPos[i];
                var y = yPos[0];
                svg_heatmap.append("rect")
                    .attr("fill", "white")
                    .attr("stroke", "blue")
                    .attr("x", x - squareSize / 2)
                    .attr("y", y - squareSize / 2)
                    .attr("width", squareSize)
                    .attr("height", squareSize);

                // core로 사용할 정사각형 박스에 코어 몇번인지 쓰기
                svg_heatmap.append("text")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .text(labels[labelIndex]);
                labelIndex++;
            }
            // Second row
            for (let i = 1; i < 3; i++) {
                var x = xPos[i];
                var y = yPos[1];

                svg_heatmap.append("rect")
                    .attr("fill", "white")
                    .attr("stroke", "blue")
                    .attr("x", x - squareSize / 2)
                    .attr("y", y - squareSize / 2)
                    .attr("width", squareSize)
                    .attr("height", squareSize);

                // core로 사용할 정사각형 박스에 코어 몇번인지 쓰기
                svg_heatmap.append("text")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .text(labels[labelIndex]);
                labelIndex++;
            }
            // Third row
            for (let i = 0; i < 4; i++) {
                var x = xPos[i];
                var y = yPos[2];
                svg_heatmap.append("rect")
                    .attr("fill", "white")
                    .attr("stroke", "blue")
                    .attr("x", x - squareSize / 2)
                    .attr("y", y - squareSize / 2)
                    .attr("width", squareSize)
                    .attr("height", squareSize);

                // core로 사용할 정사각형 박스에 코어 몇번인지 쓰기
                svg_heatmap.append("text")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .text(labels[labelIndex]);
                labelIndex++;
            }
            var padding = 80;

            function getCoreXPosition(coreIndex) {
                var x;
                switch (coreIndex) {
                    case 0:
                    case 6:
                        x = xPos[0];
                        break;

                    case 1:
                    case 4:
                    case 7:
                        x = xPos[1];
                        break;

                    case 2:
                    case 5:
                    case 8:
                        x = xPos[2];
                        break;

                    case 3:
                    case 9:
                        x = xPos[3];
                        break;
                }
                return x;
            }

            function getCoreYPosition(coreIndex) {

                if (coreIndex < 4) {
                    // First row
                    y = yPos[0]
                } else if (coreIndex < 6) {
                    // Second row
                    y = yPos[1];
                } else {
                    // Third row
                    y = yPos[2];
                }
                return y;
            }
            // 각 데이터를 숫자로 mapping
            data.forEach(function(d) {
                d.core_num = +d.core_num;
                d.down = +d.down;
                d.top = +d.top;
                d.left = +d.left;
                d.right = +d.right;
                d.time = +d.time;
                d.attack = +d.attack;
            });

            var start_row = 0;
            var end_row = 100;
            var subset_data = data.slice(start_row, end_row);
            // console.log("subset_data", subset_data);

            parsed_data = []
            for (let core_number = 0; core_number < 10; core_number++) {
                var core_traffic_sum = new Object();
                core_traffic_sum.core_num = core_number;
                core_traffic_sum.top = 0;
                core_traffic_sum.down = 0;
                core_traffic_sum.left = 0;
                core_traffic_sum.right = 0;

                for (const row of subset_data) {
                    if (row.core_num == core_number) {
                        core_traffic_sum.top = core_traffic_sum.top + row.top;
                        core_traffic_sum.down = core_traffic_sum.down + row.down;
                        core_traffic_sum.left = core_traffic_sum.left + row.left
                        core_traffic_sum.right = core_traffic_sum.right + row.right;
                    }
                }
                parsed_data.push(core_traffic_sum);
            }
            console.log(parsed_data);

            var cores = parsed_data.map(function(d) {
                return d.core_num;
            }); // Array of core ids



            // define sizes and data ranges for the legend
            var legendItems = [{
                size: 2,
                range: '0 - 14000'
            }, {
                size: 5,
                range: '14001 - 50000'
            }, {
                size: 10,
                range: '50001 - 75000'
            }, {
                size: 20,
                range: '75001 and above'
            }, ];

            // create legend group
            var legend = svg_heatmap.append('g')
                .attr('transform', `translate(${width_heatmap - 250}, ${height_heatmap - 650})`); // adjust these values to position the legend

            // add border
            legend.append('rect')
                .attr('width', 235)
                .attr('height', 310)
                .style('stroke', 'lightcoral')
                .style('fill', 'none')
                .style('stroke-width', 4);

            var legend_padding = 10;
            var arrow_width_in_legend = 80;
            var arrow_space_vertical = 80;

            // create a group for each legend item
            var legendItemGroups = legend.selectAll('g')
                .data(legendItems)
                .enter()
                .append('g')
                .attr('transform', (d, i) => `translate(${legend_padding + 10}, ${legend_padding + i * arrow_space_vertical + 4})`); // space the items vertically

            // draw arrows for each legend item, shifted to the right
            legendItemGroups.append('path')
                .attr('d', d => `M${legend_padding - d.size + arrow_width_in_legend},0 L${legend_padding + arrow_width_in_legend},0`) // shift the arrow to the right
                .attr('stroke', 'forestgreen')
                .attr('stroke-width', d => d.size) // adjust the stroke-width according to the 'size' property
                .attr('marker-start', 'url(#arrowhead)');


            // draw text for each legend item
            legendItemGroups.append('text')
                .attr('x', 100) // position the text to the right of the arrow
                .attr('y', 4) // vertically align the text with the arrow
                .text(d => d.range);






            var arrow_width_list = [1, 10, 20, 40];
            var arrow_size_list = [1, 10, 20, 30];
            // When you create your arrows, use the scales to set the size and width
            parsed_data.forEach(function(d) {
                var coreIndex = cores.indexOf(d.core_num);
                var x = getCoreXPosition(coreIndex);
                var y = getCoreYPosition(coreIndex);

                // 'directions' could be 'up', 'down', 'left', or 'right'
                // traffic_direction_list = ['top', 'down', 'left', 'right'];

                for (let direction in d) {
                    if (direction === 'core_num')
                        continue;
                    var normalized_arrow_width;
                    var normalized_arrow_size;
                    var normalized_arrow_head_width;

                    if (d[direction] >= 70000) {
                        normalized_arrow_width = arrow_width_list[3];
                        normalized_arrow_size = arrow_size_list[3];

                        normalized_arrow_head_width = arrow_width_list[2];

                    } else if (d[direction] < 70000 && d[direction] >= 20000) {
                        normalized_arrow_width = arrow_width_list[2];
                        normalized_arrow_head_width = arrow_size_list[2];

                        normalized_arrow_head_width = arrow_width_list[1];

                    } else if (d[direction] < 20000 && d[direction] >= 10000) {
                        normalized_arrow_width = arrow_width_list[1];
                        normalized_arrow_size = arrow_size_list[1];

                        normalized_arrow_head_width = arrow_width_list[0];

                    } else if (d[direction] < 10000) {
                        normalized_arrow_width = arrow_width_list[0];
                        normalized_arrow_size = arrow_size_list[0];

                        normalized_arrow_head_width = arrow_width_list[0];
                    }

                    // var arrowLength = sizeScale(d[direction]); // arrow length based on traffic
                    // var arrowWidth = widthScale(normalized_arrow_width); // arrow width based on traffic


                    // var arrowLength = sizeScale(normalized_arrow_size); // arrow length based on traffic
                    var arrowWidth = widthScale(normalized_arrow_width); // arrow width based on traffic
                    //var arrow_head_width = widthScale(normalized_arrow_head_width);
                    // console.log("arrowWidth", arrowWidth, "arrow head Width", arrow_head_width);

                    // Define arrowheads with dynamic size
                    svg_heatmap.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        .attr("refX", 0)
                        .attr("refY", 2)
                        .attr("markerWidth", arrowWidth) // Width of arrowhead based on data
                        .attr("markerHeight", arrowWidth) // Height of arrowhead based on data
                        .attr("orient", "auto-start-reverse")
                        .append("path")
                        .attr("d", "M 0,0 V 4 L4,2 Z")
                        .attr("fill", "forestgreen");

                    var fixed_length = 40;
                    // Append the arrows
                    var pathD = "";
                    switch (direction) {
                        case 'top':
                            pathD = `M${x},${y - squareSize / 2 - 50} l0,-${fixed_length}`;
                            break;
                        case 'down':
                            pathD = `M${x},${y + squareSize / 2 + 50} l0,${fixed_length}`;
                            break;
                        case 'left':
                            pathD = `M${x - squareSize / 2 - 60},${y} l-${fixed_length},0`;
                            break;
                        case 'right':
                            pathD = `M${x + squareSize / 2 + 60},${y} l${fixed_length},0`;
                            break;
                    }

                    svg_heatmap.append('path')
                        .attr('d', pathD)
                        //.attr('stroke', 'royalblue')
                        .attr('stroke', 'forestgreen')
                        .attr('fill', 'none')
                        .attr('stroke-width', arrowWidth)
                        .attr('marker-start', 'url(#arrowhead)');
                }

            });

            // 스크롤바 이벤트 추가하기
            d3.select("#my_heatmap_scrollbar").on("input", function() {
                var newValue = +this.value;

                // 현재 스크롤바가 지정된 값에서 시작해서 10 time unit만큼 자른다. -> core 10개니까 트래픽 데이터 총 100개씩 해당 됨.
                start_row = newValue * 10;
                end_row = ((newValue + 10) * 10) - 1;
                subset_data = data.slice(start_row, end_row);
                // console.log(subset_data, typeof(subset_data));

                // csv에서 불러온 데이터에서 지정된 범위만큼 데이터 더해서 core #가 같은 row끼리 더해서 새로운 dataset을 만든다.
                parsed_data = []
                for (let core_number = 0; core_number < 10; core_number++) {
                    var core_traffic_sum = new Object();
                    core_traffic_sum.core_num = core_number;
                    core_traffic_sum.top = 0;
                    core_traffic_sum.down = 0;
                    core_traffic_sum.left = 0;
                    core_traffic_sum.right = 0;

                    for (const row of subset_data) {
                        if (row.core_num == core_number) {
                            core_traffic_sum.top = core_traffic_sum.top + row.top;
                            core_traffic_sum.down = core_traffic_sum.down + row.down;
                            core_traffic_sum.left = core_traffic_sum.left + row.left
                            core_traffic_sum.right = core_traffic_sum.right + row.right;
                        }
                    }
                    parsed_data.push(core_traffic_sum);
                }

                // Redraw the chart
                redraw(parsed_data);
            });

            function redraw(parsed_data) {
                //TODO:
                svg_heatmap.selectAll("path").remove();
                svg_heatmap.selectAll("defs").remove();

                var cores = parsed_data.map(function(d) {
                    return d.core_num;
                }); // Array of core ids

                // create legend group
                var legend = svg_heatmap.append('g')
                    .attr('transform', `translate(${width_heatmap - 250}, ${height_heatmap - 650})`); // adjust these values to position the legend

                // add border
                legend.append('rect')
                    .attr('width', 235)
                    .attr('height', 310)
                    .style('stroke', 'lightcoral')
                    .style('fill', 'none')
                    .style('stroke-width', 4);

                var legend_padding = 10;
                var arrow_width_in_legend = 80;
                var arrow_space_vertical = 80;

                // create a group for each legend item
                var legendItemGroups = legend.selectAll('g')
                    .data(legendItems)
                    .enter()
                    .append('g')
                    .attr('transform', (d, i) => `translate(${legend_padding + 10}, ${legend_padding + i * arrow_space_vertical + 4})`); // space the items vertically

                // draw arrows for each legend item, shifted to the right
                legendItemGroups.append('path')
                    .attr('d', d => `M${legend_padding - d.size + arrow_width_in_legend},0 L${legend_padding + arrow_width_in_legend},0`) // shift the arrow to the right
                    .attr('stroke', 'forestgreen')
                    .attr('stroke-width', d => d.size) // adjust the stroke-width according to the 'size' property
                    .attr('marker-start', 'url(#arrowhead)');


                // draw text for each legend item
                legendItemGroups.append('text')
                    .attr('x', 100) // position the text to the right of the arrow
                    .attr('y', 4) // vertically align the text with the arrow
                    .text(d => d.range);

                var arrow_width_list = [1, 10, 20, 40];
                var arrow_size_list = [1, 10, 20, 30];


                parsed_data.forEach(function(d) {
                    var coreIndex = cores.indexOf(d.core_num);
                    var x = getCoreXPosition(coreIndex);
                    var y = getCoreYPosition(coreIndex);

                    // 'directions' could be 'up', 'down', 'left', or 'right'
                    // traffic_direction_list = ['top', 'down', 'left', 'right'];

                    for (let direction in d) {
                        if (direction === 'core_num')
                            continue;
                        var normalized_arrow_width;
                        var normalized_arrow_size;
                        var normalized_arrow_head_width;

                        if (d[direction] >= 70000) {
                            normalized_arrow_width = arrow_width_list[3];
                            normalized_arrow_size = arrow_size_list[3];

                            normalized_arrow_head_width = arrow_width_list[2];

                        } else if (d[direction] < 70000 && d[direction] >= 20000) {
                            normalized_arrow_width = arrow_width_list[2];
                            normalized_arrow_head_width = arrow_size_list[2];

                            normalized_arrow_head_width = arrow_width_list[1];

                        } else if (d[direction] < 20000 && d[direction] >= 10000) {
                            normalized_arrow_width = arrow_width_list[1];
                            normalized_arrow_size = arrow_size_list[1];

                            normalized_arrow_head_width = arrow_width_list[0];

                        } else if (d[direction] < 10000) {
                            normalized_arrow_width = arrow_width_list[0];
                            normalized_arrow_size = arrow_size_list[0];

                            normalized_arrow_head_width = arrow_width_list[0];
                        }

                        // var arrowLength = sizeScale(d[direction]); // arrow length based on traffic
                        // var arrowWidth = widthScale(normalized_arrow_width); // arrow width based on traffic


                        // var arrowLength = sizeScale(normalized_arrow_size); // arrow length based on traffic
                        var arrowWidth = widthScale(normalized_arrow_width); // arrow width based on traffic
                        //var arrow_head_width = widthScale(normalized_arrow_head_width);
                        // console.log("arrowWidth", arrowWidth, "arrow head Width", arrow_head_width);

                        // Define arrowheads with dynamic size
                        svg_heatmap.append("defs").append("marker")
                            .attr("id", "arrowhead")
                            .attr("refX", 0)
                            .attr("refY", 2)
                            .attr("markerWidth", arrowWidth) // Width of arrowhead based on data
                            .attr("markerHeight", arrowWidth) // Height of arrowhead based on data
                            .attr("orient", "auto-start-reverse")
                            .append("path")
                            .attr("d", "M 0,0 V 4 L4,2 Z")
                            .attr("fill", "forestgreen");

                        var fixed_length = 40;
                        // Append the arrows
                        var pathD = "";
                        switch (direction) {
                            case 'top':
                                pathD = `M${x},${y - squareSize / 2 - 50} l0,-${fixed_length}`;
                                break;
                            case 'down':
                                pathD = `M${x},${y + squareSize / 2 + 50} l0,${fixed_length}`;
                                break;
                            case 'left':
                                pathD = `M${x - squareSize / 2 - 60},${y} l-${fixed_length},0`;
                                break;
                            case 'right':
                                pathD = `M${x + squareSize / 2 + 60},${y} l${fixed_length},0`;
                                break;
                        }

                        svg_heatmap.append('path')
                            .attr('d', pathD)
                            //.attr('stroke', 'black')
                            .attr('stroke', 'forestgreen')
                            .attr('fill', 'none')
                            .attr('stroke-width', arrowWidth)
                            .attr('marker-start', 'url(#arrowhead)');
                    }

                });
            }
        });
    </script>
</body>

</html>